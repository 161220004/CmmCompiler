### 实验报告（二）

- 曹洋笛  161220004  2904428882@qq.com

#### 一、数据结构

- 类型 Type

  ```c
  struct Type {
    Kind kind; // 类型，int/float/array/struct/undefined
    union {
      bool isRight; // int/float/undefined专用，是否是右值
      struct { Type* eleType; int length; } array; // array专用，元素类型和元素个数
      struct { TypeNode* node; char* name; } structure; // struct专用，域的链表和结构体名
    };
  };
  ```

- 函数 Function

  ```c
  struct Function {
    char* name; // 函数名
    int lineno; // 所在行数（函数名位置）
    bool isDefined; // 是否定义（一旦存在，默认已经声明）
    Type* returnType; // 返回类型
    TypeNode* paramNode; // 参数链表
  };
  ```

- 临时变量 TypeNode（局部/全局变量，或结构体的一个域，或函数的一个参数）

  ```c
  struct TypeNode {
    Type* type; // 域/参数/变量的类型
    char* name; // 域/参数/变量的id
    int lineno; // 所在行数
    TypeNode* next; // 下一个节点
  };
  ```

- 作用域 FieldNode

  ```c
  struct FieldNode {
    FieldType type; // 作用域种类，包括GLOBAL, FUNCTION, COND_LOOP(条件/循环), F_ANONY(匿名)
    FieldNode* parent; // 其外部作用域（一个）
    Function* func; // 对于函数作用域，记录函数信息（一个）
    int varListLen; // 本作用域内的变量符号表长度
    SymElem* varSymList; // 本作用域内的变量符号表（已按id排序的有序数组，便于二分查找）
  };
  ```

- 符号表数组元素 SymElem（变量/函数/结构体符号表）

  ```c
  struct SymElem {
    bool isNull; // 是否为空
    char* name; // 变量名/函数名/结构体名
    union {
      Type* type; // 对于变量类型或结构体结构，其类型信息
      Function* func; // 对于函数，其函数信息
    };
  };
  ```

#### 二、亮点

1. Field Tree —— 作用域的灵活处理

   作用域的种类包括全局作用域（仅一个）、函数作用域（ExtDef -> Specifier FunDec **CompSt**）、条件/循环作用域（Stmt -> IF LP Exp RP **CompSt** ELSE **CompSt** | WHILE LP Exp RP **CompSt**），匿名作用域（Stmt -> **CompSt**），每个作用域维护自己的变量符号表（CompSt -> LC **DefList** StmtList RC 中的 **DefList**）。

   开始语义分析时就创建一个全局作用域的FieldNode，并把当前作用域的指针 `FieldNode* currentField` 指向全局作用域，分析时，当遇到新的局部作用域（如函数的CompSt，if/while的ComptSt），则新建一个当前作用域的子作用域，将currentField置为子作用域并分析，在分析完子作用域后再通过FieNode中的parent指针将当前作用域指针currentField置回父作用域。

   每个作用域都有一个按ID排序的变量符号表（数组），查询时可对currentField的变量符号表进行二分查找，若找到了就用，找不到就寻找其父作用域currentField->parent的变量符号表，以此类推直到全局作用域，若都找不到才判定该变量未定义。

   例如，下面一段代码得到的作用域树是这样的：

   ```c
   int a, b;
   int func(int arg1, float arg2) { // 函数作用域
     int a = 3; // 局部的a，不是全局的a
     return ((arg1 < a) && (arg2 < b));
   }
   int main() { // 函数作用域
     int c; // 局部的c
     a = 1; b = 5; // 全局的a和b
     c = func(2, 2.5); // True
     if (c) {
       float c = 2.5, d = c * 1.5; // 局部的c和d
     } else {
       int d = c + 3; // main的c，局部的d
       { // 匿名作用域
         float d = 0.5; // 局部的d
         a + b + c; // 全局的a和b，main的c
       }
     }
   }
   ```

   

2. Undefined —— 避免连环报错的类型推定

3. 层层深入 —— 交付给底层的分析模式

4. 二分查找 —— 加快查询速度

5. 更广泛的右值判定

#### 三、注意事项（一些私设）

- 对于**函数参数重名**的错误，本人把它归类为**错误类型3**（详见下面的细节说明）

- 对于**条件判断**的类型错误（如：`if(1.5)...`、`while(0.5)...`），本人归类为**错误类型7**（详见细节说明）

- 报错出现的**顺序可能不与错误出现的行号顺序相同**（例如错误类型18永远是最后才判断的）

- 对于**同名结构体的嵌套**是**不允许**的（如：`struct A {int x; struct A next;};`），因为本程序中只有一个结构体完全定义结束后才会加入结构体符号表，对于同名嵌套将报错17

- 结构体内部**域名**是**允许与任何结构体名重名**的（如：`struct A {...}; struct B {int A;};` 不报错），因为实验要求中没有说需要报错（只有变量与前面定义过的结构体名字重复时才报错）

- 对于算术运算的类型匹配，认为：

  - 加减乘除/取负：仅int/float可参与，且参与运算的**操作数类型相同**（同为int或同为float）
  - 逻辑与或非/取反：参与运算的操作数必须**同为int**
  - 关系（==/</>/...）：仅int/float可参与，参与运算的**操作数类型可以不同**（如：`1 < 1.5` 不报错）

- 根据实验要求，数组类型判断相等只需要维数和元素类型相同，不需要元素个数相同，例如：

  `int a[5][6]; int b[7][4]; a = b;` 是不会报错的

- 根据本程序**右值的判定**的方法，像 `x*y, func(4), -t` 等只要没有储存地址，出现在赋值语句左侧均报错6

- 由于Undefined的类型推测，表达式的一些错误不会连续性引发，例如：

  a是未定义的变量，则 `int b = (a + 1) * 5` 只会报一个错误类型1，因为(a + 1)作为Undefined将在 `Exp * Exp` 时被推测为int类型，并免除报错类型不匹配
  
- 为了避免输出奇怪的问题，当词法/语法分析不通过时（Lab1的错），不会进行Lab2的语义分析

#### 四、细节说明

- 为了避免一个报错引发一系列报错，对每个错误进行了细致的后续处理：

  - 错误类型1： 变量在使用时未经定义

    报错并返回一个**Undefined**类型变量

  - 错误类型2： 函数在调用时未经定义

    报错并返回一个**Undefined**类型作为结果

  - 错误类型3： 变量出现重复定义，或变量与前面定义过的结构体名字重复

    - 局部/全局变量的重复定义（位于Compst的Def/位于ExtDef）：

      报错，**不加入**符号表，即该变量名对应的类型为第一次出现时定义的类型

      （如：`int a; float a;` 的符号表里只有：a (int)）

    - **函数参数重名**（位于FuncDec的VarList，在此当作类型3报错）：

      报错，**全都加入**函数参数表和函数局部作用域表，查询的时候随机选其中的一个

  - 错误类型4： 函数出现重复定义（即同样的函数名出现了不止一次定义）

    报错，**只把第一次定义的写入**函数符号表，但是重复定义的那个函数内部按照重复定义的那个函数头和参数表来处理（即认为函数名相同是手误，**不影响函数内部**）

  - 错误类型5： 赋值号两边的表达式类型不匹配

    - 变量初始化的赋值不匹配（位于Dec）：

      报错变量的真正类型取决于**左侧Type声明的类型**（如：`int a = 1.5;` 中，a的类型判定为 int）

    - 表达式的赋值不匹配（位于Exp）：

      对于 `Exp -> Exp1 = Exp2`，当：

      - Exp2是Undefined类型，不报错（视为遗留问题），Exp的返回类型为Exp1的类型
      - Exp1是Undefined类型，不报错（视为遗留问题），可推测Exp1类型为Exp2类型并作为Exp的类型返回
      - 若Exp1、Exp2类型均已定义且不同，报错，并一律把Exp1的类型作为Exp的最终返回类型

  - 错误类型6： 赋值号左边出现一个只有右值的表达式

    （一定在表达式的赋值 `Exp -> Exp1 = Exp2` 中出现）报错后直接返回Exp1的类型作为Exp的类型

  - 错误类型7： 操作数类型不匹配或操作数类型与操作符不匹配（例如整型变量与数组变量相加减，或数组（或结构体）变量与数组（或结构体）变量相加减）

    - 表达式运算中不匹配（位于Exp）：

      对于 `Exp -> Exp1 operation Exp2`，当：

      - Exp1和Exp2均为Undefined，不报错（视为遗留问题），返回Exp类型为Undefined
      - Exp1和Exp2有一个是Undefined，不报错（视为遗留问题），返回两者中已定义的那个类型
      - Exp1和Exp2均已定义且不匹配，报错，对加减乘除运算返回**Undefined的右值类型**；对逻辑运算和关系运算返回**int的右值类型**

    - **条件判断**中不是int（如：`if(1.5)...`、`while(0.5)...`，位于Stmt）：

      直接报错，无需其他处理

  - 错误类型8： return语句的返回类型与函数定义的返回类型不匹配

    直接报错，无需其他处理

  - 错误类型9： 函数调用时实参与形参的数目或类型不匹配

    报错，此函数调用表达式返回该函数**正确的返回类型**

  - 错误类型10： 对非数组型变量使用“[…]” （数组访问）操作符

    报错并返回一个**Undefined**类型作为结果

  - 错误类型11： 对普通变量使用“(…)”或“()” （函数调用）操作符

    报错并返回一个**Undefined**类型作为结果

  - 错误类型12： 数组访问操作符“[…]” 中出现非整数（例如a[1.5]）

    报错并返回该数组的**元素类型**

  - 错误类型13： 对非结构体型变量使用“.” 操作符

    报错并返回一个**Undefined**类型作为结果

  - 错误类型14： 访问结构体中未定义过的域

    报错并返回一个**Undefined**类型作为结果

  - 错误类型15： 结构体中域名重复定义（指同一结构体中） ，或在定义时对域进行初始化（例如struct A { int a = 0; }）

    - 域名重复定义：报错，不必删除重复的域节点，查询域时找到的是第一次定义的重名节点
    - 定义时对域进行初始化：报错后直接忽视后面的初始化部分

  - 错误类型16： 结构体的名字与前面定义过的结构体或变量的名字重复

    报错，重名的结构体不加入结构体符号表

  - 错误类型17： 直接使用未定义过的结构体来定义变量

    报错并返回一个**Undefined**类型作为结果

  - 错误类型18： 函数进行了声明，但没有被定义

    在最后直接报错，无需其他处理

  - 错误类型19： 函数的多次声明互相冲突（即函数名一致，但返回类型、形参数量或者形参类型不一致），或者声明与定义之间互相冲突

    - 多次声明冲突时，报错后不再加入函数符号表，即函数符号表中只保留第一次声明的函数类型
    - 声明与定义冲突时，报错后定义的类型不再加入函数符号表，即函数符号表中只保留声明的函数类型，但并不影响函数定义内部的语义分析
    
    