### 实验报告（二）

- 曹洋笛  161220004  2904428882@qq.com

#### 一、数据结构

- 类型 Type
- 函数 Function
- 临时变量 TypeNode（局部/全局变量，或结构体的一个域，或函数的一个参数）
- 作用域 FieldNode
- 符号表数组元素 SymElem（变量/函数/结构体符号表）

#### 二、亮点

1. Field Tree —— 作用域的灵活处理
2. Undefined —— 避免连环报错的类型推定
3. 层层深入 —— 交付给底层的分析模式
4. 二分查找 —— 加快查询速度

#### 三、注意事项（一些私设）

- 对于**函数参数重名**的错误，本人把它归类为**错误类型3**（详见下面的细节说明）

- 对于**条件判断**的类型错误（如：`if(1.5)...`、`while(0.5)...`），本人归类为**错误类型7**（详见细节说明）

- 报错出现的**顺序可能不与错误出现的行号顺序相同**（因为struct的域链表等TypeNode链表是反的，且错误类型18永远是最后才判断的）

- 对于**同名结构体的嵌套**是**不允许**的（如：`struct A {int x; struct A next;};`），因为本程序中只有一个结构体完全定义结束后才会加入结构体符号表，对于同名嵌套将报错17

- 结构体内部**域名**是**允许与任何结构体名重名**的（如：`struct A {...}; struct B {int A;};` 不报错），因为实验要求中没有说需要报错（只有变量与前面定义过的结构体名字重复时才报错）

- 对于算术运算的类型匹配，认为：

  - 加减乘除/取负：仅int/float可参与，且参与运算的**操作数类型相同**（同为int或同为float）
  - 逻辑与或非/取反：参与运算的操作数必须**同为int**
  - 关系（==/</>/...）：仅int/float可参与，参与运算的**操作数类型可以不同**（如：`1 < 1.5` 不报错）

- 根据实验要求，数组类型判断相等只需要维数和元素类型相同，不需要元素个数相同，例如：

  `int a[5][6]; int b[7][4]; a = b;` 是不会报错的

- 根据本程序**右值的判定**的方法，像 `x*y, func(4), -t` 等只要没有储存地址，出现在赋值语句左侧均报错6

- 由于Undefined的类型推测，表达式的一些错误不会连续性引发，例如：

  a是未定义的变量，则 `int b = (a + 1) * 5` 只会报一个错误类型1，因为(a + 1)作为Undefined将在 `Exp * Exp` 时被推测为int类型，并免除报错类型不匹配

#### 四、细节说明

- 为了避免一个报错引发一系列报错，对每个错误进行了细致的后续处理：

  - 错误类型1： 变量在使用时未经定义

    报错并返回一个**Undefined**类型变量

  - 错误类型2： 函数在调用时未经定义

    报错并返回一个**Undefined**类型作为结果

  - 错误类型3： 变量出现重复定义，或变量与前面定义过的结构体名字重复

    - 局部/全局变量的重复定义（位于Compst的Def/位于ExtDef）：

      报错，**不加入**符号表，即该变量名对应的类型为第一次出现时定义的类型

      （如：`int a; float a;` 的符号表里只有：a (int)）

    - **函数参数重名**（位于FuncDec的VarList，在此当作类型3报错）：

      报错，**全都加入**函数参数表和函数局部作用域表，查询的时候随机选其中的一个

  - 错误类型4： 函数出现重复定义（即同样的函数名出现了不止一次定义）

    报错，**只把第一次定义的写入**函数符号表，但是重复定义的那个函数内部按照重复定义的那个函数头和参数表来处理（即认为函数名相同是手误，**不影响函数内部**）

  - 错误类型5： 赋值号两边的表达式类型不匹配

    - 变量初始化的赋值不匹配（位于Dec）：

      报错变量的真正类型取决于**左侧Type声明的类型**（如：`int a = 1.5;` 中，a的类型判定为 int）

    - 表达式的赋值不匹配（位于Exp）：

      对于 `Exp -> Exp1 = Exp2`，当：

      - Exp2是Undefined类型，不报错（视为遗留问题），Exp的返回类型为Exp1的类型
      - Exp1是Undefined类型，不报错（视为遗留问题），可推测Exp1类型为Exp2类型并作为Exp的类型返回
      - 若Exp1、Exp2类型均已定义且不同，报错，并一律把Exp1的类型作为Exp的最终返回类型

  - 错误类型6： 赋值号左边出现一个只有右值的表达式

    （一定在表达式的赋值 `Exp -> Exp1 = Exp2` 中出现）报错后直接返回Exp1的类型作为Exp的类型

  - 错误类型7： 操作数类型不匹配或操作数类型与操作符不匹配（例如整型变量与数组变量相加减，或数组（或结构体）变量与数组（或结构体）变量相加减）

    - 表达式运算中不匹配（位于Exp）：

      对于 `Exp -> Exp1 operation Exp2`，当：

      - Exp1和Exp2均为Undefined，不报错（视为遗留问题），返回Exp类型为Undefined
      - Exp1和Exp2有一个是Undefined，不报错（视为遗留问题），返回两者中已定义的那个类型
      - Exp1和Exp2均已定义且不匹配，报错，对加减乘除运算返回**Undefined的右值类型**；对逻辑运算和关系运算返回**int的右值类型**

    - **条件判断**中不是int（如：`if(1.5)...`、`while(0.5)...`，位于Stmt）：

      直接报错，无需其他处理

  - 错误类型8： return语句的返回类型与函数定义的返回类型不匹配

    直接报错，无需其他处理

  - 错误类型9： 函数调用时实参与形参的数目或类型不匹配

    报错，此函数调用表达式返回该函数**正确的返回类型**

  - 错误类型10： 对非数组型变量使用“[…]” （数组访问）操作符

    报错并返回一个**Undefined**类型作为结果

  - 错误类型11： 对普通变量使用“(…)”或“()” （函数调用）操作符

    报错并返回一个**Undefined**类型作为结果

  - 错误类型12： 数组访问操作符“[…]” 中出现非整数（例如a[1.5]）

    报错并返回该数组的**元素类型**

  - 错误类型13： 对非结构体型变量使用“.” 操作符

    报错并返回一个**Undefined**类型作为结果

  - 错误类型14： 访问结构体中未定义过的域

    报错并返回一个**Undefined**类型作为结果

  - 错误类型15： 结构体中域名重复定义（指同一结构体中） ，或在定义时对域进行初始化（例如struct A { int a = 0; }）

    - 域名重复定义：报错，不必删除重复的域节点，查询域时找到的是最后定义的重名节点
    - 定义时对域进行初始化：报错后直接忽视后面的初始化部分

  - 错误类型16： 结构体的名字与前面定义过的结构体或变量的名字重复

    报错，重名的结构体不加入结构体符号表

  - 错误类型17： 直接使用未定义过的结构体来定义变量

    报错并返回一个**Undefined**类型作为结果

  - 错误类型18： 函数进行了声明，但没有被定义

    在最后直接报错，无需其他处理

  - 错误类型19： 函数的多次声明互相冲突（即函数名一致，但返回类型、形参数量或者形参类型不一致），或者声明与定义之间互相冲突

    